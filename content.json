{"meta":{"title":"walkbird的blog","subtitle":null,"description":null,"author":"韩欣宇","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2019-01-25T07:59:21.000Z","updated":"2019-01-25T07:59:21.377Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"go语言不定参数","slug":"go语言不定参数","date":"2019-03-12T03:01:46.000Z","updated":"2019-03-12T03:09:14.276Z","comments":true,"path":"2019/03/12/go语言不定参数/","link":"","permalink":"http://yoursite.com/2019/03/12/go语言不定参数/","excerpt":"","text":"一、函数的定义12func Add(v ...interface&#123;&#125;)&#123;&#125; 该函数定义，定义了一个可以接受任何数目，任何类型的函数。在一个变量后面加上三个点”…”，就表示从该变量处开始接受不定参数。如果类型不是interface{},而是某一确定类型，则为接受该类型的不定参数。 下面一个例子 ##1234567891011121314151617181920package mainimport ( \"fmt\")/*不定参数函数*/func Add(a int, args ...int) (result int) &#123; result += a for _, arg := range args &#123; result += arg &#125; return&#125;func main() &#123; fmt.Println(Add(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))&#125; 123456789101112131415161718192021222324252627282930/*任意类型的不定参数，用interface&#123;&#125;表示*/func MyPrintf(args ...interface&#123;&#125;) &#123; for _, arg := range args &#123; //迭代不定参数 switch arg.(type) &#123; case int: fmt.Println(arg, \"is int\") case string: fmt.Println(arg, \"is string\") case float64: fmt.Println(arg, \"is float64\") case bool: fmt.Println(arg, \" is bool\") default: fmt.Println(\"未知的类型\") &#125; &#125;&#125;func main() &#123; /*输出结果： 12 is int haha is string 12.5 is float64 false is bool -12.5 is float64 */ MyPrintf(12, \"haha\", 12.5, false, -12.5)&#125;","categories":[],"tags":[]},{"title":"跳表","slug":"跳表","date":"2019-03-07T07:44:52.000Z","updated":"2019-03-12T03:02:54.256Z","comments":true,"path":"2019/03/07/跳表/","link":"","permalink":"http://yoursite.com/2019/03/07/跳表/","excerpt":"","text":"什么是跳表所谓跳表，就是一个链表，通过给此链表建立索引之后，多层索引与原是链表组成的就是一个跳表。每层索引都是一个新的更短的链表，可以指到下一层链表的链表。每次检索都是从最高的维度进行检索，在逐渐降低维度从而达到时间复杂度无限接近O(logn)，理想的跳表是每一层的元素是下一层的一半，个人认为类似二叉树。 跳表的性质 由多层结构组成（类似一个台阶） 每一层都是一个有序链表 最底层包含所有链表中的元素 如果一个元素在某一层出现，则他在下一层的链表中也会出现 每个节点包含两个指针，指向同层的下一个元素，指向下一层的元素 下面几张图来表示跳表的检索过程对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低。","categories":[],"tags":[]},{"title":"mysql","slug":"mysql","date":"2019-02-19T02:50:44.000Z","updated":"2019-02-19T06:59:11.590Z","comments":true,"path":"2019/02/19/mysql/","link":"","permalink":"http://yoursite.com/2019/02/19/mysql/","excerpt":"","text":"mysql执行过程 存储引擎支持支持 InnoDB、MyISAM、Memory 等多个存储引擎，最常用的是innodb，从mysql5.5.5版本开始就是默认的存储引擎。 一条查询语句执行过程 通过连接器连接到数据库上。 连接器负责跟客服端建立连接、获取权限、维持管理连接。连接的命令通常如下： 1mysql -h $ip -P $port -u $user -p 查看缓存 建立连接之后，就可以执行select语句了，执行过程就来到了第二步骤–查询缓存，查看之前是否被执行过这样的sql用缓存的结果来返回。 如果没有命中查询缓存，那就要开始执行sql语句了，语法分析,识别出sql语句中每个字符串分别代表什么。 接下来语法没有错误之后，在经过优化器，优化器在表中有很多索引的时候决定使用哪个索引，或者在join的时候决定各个表的链接顺序。 优化之后就开始执行了，通过数据库引擎获取表的第一行，判断是否符合条件，不是就跳过，接着通过引擎取下一行，直到最后一行。最后讲将结果集返回。 一条更新语句执行过程","categories":[],"tags":[]},{"title":"springboot","slug":"springboot","date":"2019-02-14T02:20:53.000Z","updated":"2019-02-14T02:20:53.762Z","comments":true,"path":"2019/02/14/springboot/","link":"","permalink":"http://yoursite.com/2019/02/14/springboot/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"rpc协议","slug":"rpc协议","date":"2019-02-13T07:37:41.000Z","updated":"2019-02-14T02:13:48.685Z","comments":true,"path":"2019/02/13/rpc协议/","link":"","permalink":"http://yoursite.com/2019/02/13/rpc协议/","excerpt":"","text":"RPC协议的定义RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内应用程序更加容易。 简单的说，RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器） 上的一个函数或方法（可以统称为服务）并得到返回的结果 RPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯） RPC 是一个请求响应模型。客户端发起请求，服务器返回响应（类似于Http的工作方式） RPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。 RPC协议的请求报文格式 XID 这是一个RPC报文的编号，每次递增1。 Message Type 这是RPC报文的类型。RPC报文分为两种：请求消息用0表示，应答消息用1表示。 RPC Version 这是RPC协议本身的版本编号，目前通用的是版本2。 Program 这是RPC程序编号。比如请求的是NFS服务，则这个字段为100003。 Version 这是RPC程序版本。比如请求的是NFSV2，则这个字段为2。 Procedure 这是RPC例程编号。比如请求删除一个文件，则这个字段为10。 Credentials 这是包含了用户信息，供服务器进行验证。 Verifier 这是认证信息的验证值，这个字段也跟认证方式有关。 RPC应答报文格式 XID 这是RPC报文的编号，取值与请求报文中的XID一致，客户端靠这个字段分配应答消息对应哪次RPC请求。 Message Type RPC消息类型，这里取值为1，表示应答消息。 Reply State 是一个应答标志。当服务器端接收到RPC请求后会对报文格式进行检查，如果格式正确，是一个有效的RPC请求，则将Reply State设置为0，表示格式正确。 Verifier 服务器端会解析RPC请求消息中的用户信息，对用户进行验证，根据结果填写Verifier字段，这个字段中包含了身份验证后的信息，这个字段和认证类型有关。 Accept State 这个字段表示服务器是否可以处理一个RPC请求，假如服务器不支持NFS服务，那么当接收到一个Program为100003的RPC消息后，就会拒绝这个请求。如果服务器中包含RPC消息中请求的处理程序，则接收这个请求。0表示接收请求，其他值表示不接收请求。 RPC工作过程 服务消费方（client）调用以本地调用方式调用服务； client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； client stub找到服务地址，并将消息发送到服务端； server stub收到消息后进行解码； server stub根据解码结果调用本地的服务； 本地服务执行并将结果返回给server stub； server stub将返回结果打包成消息并发送至消费方； client stub接收到消息，并进行解码； 服务消费方得到最终结果。 net/rpcGo官方提供了一个RPC库: net/rpc。包rpc提供了通过网络访问一个对象的方法的能力。服务器需要注册对象，通过对象的类型名暴露这个服务。注册后这个对象的输出方法就可以远程调用，这个库封装了底层传输的细节，包括序列化。服务器可以注册多个不同类型的对象，但是注册相同类型的多个对象的时候回出错。 声明服务1func (t *T) MethodName(argType T1, replyType *T2) error 调用服务1err = client.Call(\"T.MethodName\", T1, &amp;T2)","categories":[],"tags":[]},{"title":"","slug":"java初级","date":"2019-02-12T06:57:24.758Z","updated":"2019-02-13T08:43:49.138Z","comments":true,"path":"2019/02/12/java初级/","link":"","permalink":"http://yoursite.com/2019/02/12/java初级/","excerpt":"","text":"java…………HIIMHIMHMMHMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:………….………..MMMI:MII:MIHMHMMMMMHMMMMIMMMIMMMMMMMMMMMMMM………….………:MMMI:M::HM::MIHHHM:IM:MHM:IMH:IMMMIIMMMHMMMH:………………..:MMMHHM::MMI:HH:MM:I:M:MMMH:IMH:IMM::MH:MM:MM:M……………….MMMMHMM:MMIMHMII:MM:IIIM:MHMIMMM:MMIIH::MH:HM:M……………… :MIMMMMMMMMMHMMHMM:HHMHMMMMIMHMMMMHMHMIHIHM::MMI……………….M:MMMMMMMMMMMMHMMMMMMMMHMMMMMMMMMMHMMMHMMIMHMMMM:………..…….HHMMMMMMMMMMMMMMMMIMMMM.MMHMMMMHMMMMMMMMMMMIMHMMI………..……..MMMIMMMMMMMMMMIHMIMIM:.M:HMM:MIHMMMMMMMMMMMMMMMI………..……..MM.MMMMMMMMMMMH:MMMHM:.M.:MM.M.HMMMHMMMMMMMMMMMI………..……..MM.MMMMMMMMMMH::M.M.M..M..MM:M.IIMH:MMMMMMMMMMMI………..……..M:.MM:MMMMMMM:.I..:.I..H..IM:I.I.M.IMHMMMMMMMMMI………..……..M..MMMHMMMMM.:HI:HHH……H….II..:MMMMMMMHMM:………..………..MM.MIMMMM.:H: .::I…….. …:IH:.MMMMMM:MMI………..………..:H..MMMIM.M.:…:I………: ..::HHHMMMMIMMMH………..…………H..IMM:I:..I:..:……….I:..:I:::MMMMMMMMM………..……………MMH::I…I:::……….III.I::MMMHMMMMMMM………..…………..MMMHMII.. …………..:MI:I.HIIIHM:HMMMM………..………….:MMMMIM::………..:……:H..:II:MHIMMMMM………..………….MMMMMMMMM………………….I.MMMHHMMMMM:……….…………MMMMH:MMMMM……..:.:………:MMMMMMMMMMMMI……….………..MMMMMMHMMMMMMM.. ………….:MMMMMMMMMMMMMMM……….…….. .IMMMMMMMMMMMMMMMM…………:MMMMMMMMMHMMMMMMM……….……….MMMMMMMMMMMMMMMMMI:…….:IHMMMMMMMMM::MMMMMMM……….………MMMMMMMIMMMMMMMMMMH:::I:I:.::HMMMMMMMMMHMMMMMMMMI……………..HMMMMMMM:MMMMMMMMMMI:::::::..:HMMMMMMMMIMMMMMMMMMM…………….IMMMMM..MI:MMMMMMMMM::::..:::::.MMMMMMMMMMMMMMMMMMM ……..……:MMMM….:MMHMMMMMM:::::…..::.:.MMMMMMMHMMMMMMMMMM……………MMI….:::IMMMMI:.:::::…..:I::::::HMMMHIM::::::MMMH……..…..MM…..:::IMIMMM:…….:….::::::::IMMHMM:I:::I:::MM …….….MMM…..:I:.MIHMMM……..:…:::::::HMMMMI:::::….::M:…….…:MM:……..:MMMHMM………………IMMMMM::………..M…….…MMM……..:::MMMMM……:……….:HMMMMM::………………...:MM:…….:::::MMMM……….. .. .::MMM:HM::………….:…....MMM……..:::::MMMMM:I..HHIMHMHHHM :IMMHIMH::………….I…..","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-01-23T08:06:02.542Z","updated":"2019-01-23T08:06:02.542Z","comments":true,"path":"2019/01/23/hello-world/","link":"","permalink":"http://yoursite.com/2019/01/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"go基本语法","slug":"golang","date":"2018-07-30T07:11:41.000Z","updated":"2019-02-13T07:39:01.113Z","comments":true,"path":"2018/07/30/golang/","link":"","permalink":"http://yoursite.com/2018/07/30/golang/","excerpt":"","text":"golang1. 特征 简明扼要，开发效率高。 编译型语言执行速度快。 有先进的并发支持模型。 可以全自动地垃圾回收。 自带工具强制编码风格。 强大的标准库应用广泛。 2. 变量 变量是一个或多个存储数据的内存 声明变量 可以用var关键字，也可以使用精简写法,例如下面:123var x inty := 1x=y","categories":[],"tags":[]}]}